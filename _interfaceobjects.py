from abc import ABC
from _operations import NewStaticOp, ChangeStaticValueOp, RegToStackOp, NestedOp
from _mathoperations import AdditionOp, SubtractionOp, MultiplicationOp
from _compareoperations import EqualOp, NotEqualOp


class InterfaceObj(ABC):
    """
    Abstract Base Class for the Interface Object. This contain the
    buffer list used by all the subclasses for the stocking of the
    operations producted by there. This buffer list is a trick for
    the compilation, use with caution.
    """
    # C'Ã¨ da overloaddare __init__ per creare InterfaceObj
    buffer = []

    @classmethod
    def GetBuffer(cls):
        """
        Will return the shared buffer of all the InterfaceObj subclasses.
        :return: The InterfaceObj Buffer
        """
        tmp = cls.buffer
        cls.buffer = []
        return tmp


class NestedInterfaceObj(ABC):
    """
    Abstract Base Class for the Nested Interface Object. This is
    different from classic Interface Object. This contain the
    method and the attribute definition for the NestedInterface
    infrastructure for the Operations.
    """
    def __init__(self):
        """Initialization of protected Operation Object attribute for subclasses."""
        self._OPERATION = None

    def getOp(self):
        """Get the Operation Object generated by the command."""
        return self._OPERATION


class VAR(InterfaceObj):
    """
    This command will create a new variable in the stack.
    This command can take as value a NestedInterfaceObj SubClass.
    """
    def __init__(self, name, value=0):  # TODO: Typecoding
        """
        This command will create a new variable in the stack.
        :param name: Name of the new variable
        :param value: Value assigned at the variable
        """
        # PER ORA SOLO VALORI NUMERICI PURI
        if isinstance(value, NestedInterfaceObj):
            oplist = [NewStaticOp(name, 0), value.getOp(), RegToStackOp(name)]
            op = NestedOp(oplist)
        else:
            op = NewStaticOp(name, value)
        self.buffer.append(op)


class SET(InterfaceObj):
    """
    This command will edit the value into a already existing variable
    in the stack.
    This command can take as value a NestedInterfaceObj SubClass.
    """
    def __init__(self, name, value = 0):
        """
        This command will edit the value into a already existing variable
        in the stack.
        This command can take as value a NestedInterfaceObj SubClass.
        :param name: Name of the variable to be changed.
        :param value: Value or NestedInterfaceObj to be inserted in the variable.
        """
        if isinstance(value, NestedInterfaceObj):
            oplist = [value.getOp(), RegToStackOp(name)]
            op = NestedOp(oplist)
        else:
            op = ChangeStaticValueOp(name, value)
        self.buffer.append(op)


class ADD(InterfaceObj, NestedInterfaceObj):
    """
    This command will sum two variable using a Registry as output.
    This command is a NestedInterfaceObj.
    """
    def __init__(self, name1, name2):
        """
        This command will sum two variable using a Registry as output.
        This command is a NestedInterfaceObj.
        :param name1: First member
        :param name2: Second member
        """
        super().__init__()
        self._OPERATION = AdditionOp(name1, name2)


class SUB(InterfaceObj, NestedInterfaceObj):
    """
    This command will subtract two variable using a Registry as output.
    The algorithm is classical progressive subtraction.
    This command is a NestedInterfaceObj.
    """
    def __init__(self, name1, name2):
        """
        This command will sum two variable using a Registry as output.
        This command is a NestedInterfaceObj.
        :param name1: First member
        :param name2: Second member
        """
        super().__init__()
        self._OPERATION = SubtractionOp(name1, name2)


class MUL(InterfaceObj, NestedInterfaceObj):
    """
    This command will multiply two variable using a Registry as output.
    The algorithm use heavily the registry for the operations.
    This command is a NestedInterfaceObj.
    """
    def __init__(self, name1, name2):
        """
        This command will multiply two variable using a Registry as output.
        The algorithm use heavily the registry for the operations.
        This command is a NestedInterfaceObj.
        :param name1: First member
        :param name2: Second member
        """
        super().__init__()
        self._OPERATION = MultiplicationOp(name1, name2)


class EQ(InterfaceObj, NestedInterfaceObj):
    # TODO: DOCUMENTAZIONE EQ
    def __init__(self, name1, name2):
        super().__init__()
        self._OPERATION = EqualOp(name1, name2)


class NEQ(InterfaceObj, NestedInterfaceObj):
    # TODO: DoCUMENTAZIONE NEQ
    def __init__(self, name1, name2):
        super().__init__()
        self._OPERATION = NotEqualOp(name1, name2)

